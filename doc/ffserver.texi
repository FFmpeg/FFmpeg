\input texinfo @c -*- texinfo -*-
@documentencoding UTF-8

@settitle ffserver Documentation
@titlepage
@center @titlefont{ffserver Documentation}
@end titlepage

@top

@contents

@chapter Synopsis

ffserver [@var{options}]

@chapter Description
@c man begin DESCRIPTION

@command{ffserver} is a streaming server for both audio and video.
It supports several live feeds, streaming from files and time shifting
on live feeds. You can seek to positions in the past on each live
feed, provided you specify a big enough feed storage.

@command{ffserver} is configured through a configuration file, which
is read at startup. If not explicitly specified, it will read from
@file{/etc/ffserver.conf}.

@command{ffserver} receives prerecorded files or FFM streams from some
@command{ffmpeg} instance as input, then streams them over
RTP/RTSP/HTTP.

An @command{ffserver} instance will listen on some port as specified
in the configuration file. You can launch one or more instances of
@command{ffmpeg} and send one or more FFM streams to the port where
ffserver is expecting to receive them. Alternately, you can make
@command{ffserver} launch such @command{ffmpeg} instances at startup.

Input streams are called feeds, and each one is specified by a
@code{<Feed>} section in the configuration file.

For each feed you can have different output streams in various
formats, each one specified by a @code{<Stream>} section in the
configuration file.

@chapter Detailed description

@command{ffserver} works by forwarding streams encoded by
@command{ffmpeg}, or pre-recorded streams which are read from disk.

Precisely, @command{ffserver} acts as an HTTP server, accepting POST
requests from @command{ffmpeg} to acquire the stream to publish, and
serving RTSP clients or HTTP clients GET requests with the stream
media content.

A feed is an @ref{FFM} stream created by @command{ffmpeg}, and sent to
a port where @command{ffserver} is listening.

Each feed is identified by a unique name, corresponding to the name
of the resource published on @command{ffserver}, and is configured by
a dedicated @code{Feed} section in the configuration file.

The feed publish URL is given by:
@example
http://@var{ffserver_ip_address}:@var{http_port}/@var{feed_name}
@end example

where @var{ffserver_ip_address} is the IP address of the machine where
@command{ffserver} is installed, @var{http_port} is the port number of
the HTTP server (configured through the @option{HTTPPort} option), and
@var{feed_name} is the name of the corresponding feed defined in the
configuration file.

Each feed is associated to a file which is stored on disk. This stored
file is used to send pre-recorded data to a player as fast as
possible when new content is added in real-time to the stream.

A "live-stream" or "stream" is a resource published by
@command{ffserver}, and made accessible through the HTTP protocol to
clients.

A stream can be connected to a feed, or to a file. In the first case,
the published stream is forwarded from the corresponding feed
generated by a running instance of @command{ffmpeg}, in the second
case the stream is read from a pre-recorded file.

Each stream is identified by a unique name, corresponding to the name
of the resource served by @command{ffserver}, and is configured by
a dedicated @code{Stream} section in the configuration file.

The stream access HTTP URL is given by:
@example
http://@var{ffserver_ip_address}:@var{http_port}/@var{stream_name}[@var{options}]
@end example

The stream access RTSP URL is given by:
@example
http://@var{ffserver_ip_address}:@var{rtsp_port}/@var{stream_name}[@var{options}]
@end example

@var{stream_name} is the name of the corresponding stream defined in
the configuration file. @var{options} is a list of options specified
after the URL which affects how the stream is served by
@command{ffserver}. @var{http_port} and @var{rtsp_port} are the HTTP
and RTSP ports configured with the options @var{HTTPPort} and
@var{RTSPPort} respectively.

In case the stream is associated to a feed, the encoding parameters
must be configured in the stream configuration. They are sent to
@command{ffmpeg} when setting up the encoding. This allows
@command{ffserver} to define the encoding parameters used by
the @command{ffmpeg} encoders.

The @command{ffmpeg} @option{override_ffserver} commandline option
allows one to override the encoding parameters set by the server.

Multiple streams can be connected to the same feed.

For example, you can have a situation described by the following
graph:

@verbatim
               _________       __________
              |         |     |          |
ffmpeg 1 -----| feed 1  |-----| stream 1 |
    \         |_________|\    |__________|
     \                    \
      \                    \   __________
       \                    \ |          |
        \                    \| stream 2 |
         \                    |__________|
          \
           \   _________       __________
            \ |         |     |          |
             \| feed 2  |-----| stream 3 |
              |_________|     |__________|

               _________       __________
              |         |     |          |
ffmpeg 2 -----| feed 3  |-----| stream 4 |
              |_________|     |__________|

               _________       __________
              |         |     |          |
              | file 1  |-----| stream 5 |
              |_________|     |__________|

@end verbatim

@anchor{FFM}
@section FFM, FFM2 formats

FFM and FFM2 are formats used by ffserver. They allow storing a wide variety of
video and audio streams and encoding options, and can store a moving time segment
of an infinite movie or a whole movie.

FFM is version specific, and there is limited compatibility of FFM files
generated by one version of ffmpeg/ffserver and another version of
ffmpeg/ffserver. It may work but it is not guaranteed to work.

FFM2 is extensible while maintaining compatibility and should work between
differing versions of tools. FFM2 is the default.

@section Status stream

@command{ffserver} supports an HTTP interface which exposes the
current status of the server.

Simply point your browser to the address of the special status stream
specified in the configuration file.

For example if you have:
@example
<Stream status.html>
Format status

# Only allow local people to get the status
ACL allow localhost
ACL allow 192.168.0.0 192.168.255.255
</Stream>
@end example

then the server will post a page with the status information when
the special stream @file{status.html} is requested.

@section How do I make it work?

As a simple test, just run the following two command lines where INPUTFILE
is some file which you can decode with ffmpeg:

@example
ffserver -f doc/ffserver.conf &
ffmpeg -i INPUTFILE http://localhost:8090/feed1.ffm
@end example

At this point you should be able to go to your Windows machine and fire up
Windows Media Player (WMP). Go to Open URL and enter

@example
    http://<linuxbox>:8090/test.asf
@end example

You should (after a short delay) see video and hear audio.

WARNING: trying to stream test1.mpg doesn't work with WMP as it tries to
transfer the entire file before starting to play.
The same is true of AVI files.

You should edit the @file{ffserver.conf} file to suit your needs (in
terms of frame rates etc). Then install @command{ffserver} and
@command{ffmpeg}, write a script to start them up, and off you go.

@section What else can it do?

You can replay video from .ffm files that was recorded earlier.
However, there are a number of caveats, including the fact that the
ffserver parameters must match the original parameters used to record the
file. If they do not, then ffserver deletes the file before recording into it.
(Now that I write this, it seems broken).

You can fiddle with many of the codec choices and encoding parameters, and
there are a bunch more parameters that you cannot control. Post a message
to the mailing list if there are some 'must have' parameters. Look in
ffserver.conf for a list of the currently available controls.

It will automatically generate the ASX or RAM files that are often used
in browsers. These files are actually redirections to the underlying ASF
or RM file. The reason for this is that the browser often fetches the
entire file before starting up the external viewer. The redirection files
are very small and can be transferred quickly. [The stream itself is
often 'infinite' and thus the browser tries to download it and never
finishes.]

@section Tips

* When you connect to a live stream, most players (WMP, RA, etc) want to
buffer a certain number of seconds of material so that they can display the
signal continuously. However, ffserver (by default) starts sending data
in realtime. This means that there is a pause of a few seconds while the
buffering is being done by the player. The good news is that this can be
cured by adding a '?buffer=5' to the end of the URL. This means that the
stream should start 5 seconds in the past -- and so the first 5 seconds
of the stream are sent as fast as the network will allow. It will then
slow down to real time. This noticeably improves the startup experience.

You can also add a 'Preroll 15' statement into the ffserver.conf that will
add the 15 second prebuffering on all requests that do not otherwise
specify a time. In addition, ffserver will skip frames until a key_frame
is found. This further reduces the startup delay by not transferring data
that will be discarded.

@section Why does the ?buffer / Preroll stop working after a time?

It turns out that (on my machine at least) the number of frames successfully
grabbed is marginally less than the number that ought to be grabbed. This
means that the timestamp in the encoded data stream gets behind realtime.
This means that if you say 'Preroll 10', then when the stream gets 10
or more seconds behind, there is no Preroll left.

Fixing this requires a change in the internals of how timestamps are
handled.

@section Does the @code{?date=} stuff work.

Yes (subject to the limitation outlined above). Also note that whenever you
start ffserver, it deletes the ffm file (if any parameters have changed),
thus wiping out what you had recorded before.

The format of the @code{?date=xxxxxx} is fairly flexible. You should use one
of the following formats (the 'T' is literal):

@example
* YYYY-MM-DDTHH:MM:SS     (localtime)
* YYYY-MM-DDTHH:MM:SSZ    (UTC)
@end example

You can omit the YYYY-MM-DD, and then it refers to the current day. However
note that @samp{?date=16:00:00} refers to 16:00 on the current day -- this
may be in the future and so is unlikely to be useful.

You use this by adding the ?date= to the end of the URL for the stream.
For example:   @samp{http://localhost:8080/test.asf?date=2002-07-26T23:05:00}.
@c man end

@chapter Options
@c man begin OPTIONS

@include fftools-common-opts.texi

@section Main options

@table @option
@item -f @var{configfile}
Read configuration file @file{configfile}. If not specified it will
read by default from @file{/etc/ffserver.conf}.

@item -n
Enable no-launch mode. This option disables all the @code{Launch}
directives within the various @code{<Feed>} sections. Since
@command{ffserver} will not launch any @command{ffmpeg} instances, you
will have to launch them manually.

@item -d
Enable debug mode. This option increases log verbosity, and directs
log messages to stdout. When specified, the @option{CustomLog} option
is ignored.
@end table

@chapter Configuration file syntax

@command{ffserver} reads a configuration file containing global
options and settings for each stream and feed.

The configuration file consists of global options and dedicated
sections, which must be introduced by "<@var{SECTION_NAME}
@var{ARGS}>" on a separate line and must be terminated by a line in
the form "</@var{SECTION_NAME}>". @var{ARGS} is optional.

Currently the following sections are recognized: @samp{Feed},
@samp{Stream}, @samp{Redirect}.

A line starting with @code{#} is ignored and treated as a comment.

Name of options and sections are case-insensitive.

@section ACL syntax
An ACL (Access Control List) specifies the address which are allowed
to access a given stream, or to write a given feed.

It accepts the following forms
@itemize
@item
Allow/deny access to @var{address}.
@example
ACL ALLOW <address>
ACL DENY <address>
@end example

@item
Allow/deny access to ranges of addresses from @var{first_address} to
@var{last_address}.
@example
ACL ALLOW <first_address> <last_address>
ACL DENY <first_address> <last_address>
@end example
@end itemize

You can repeat the ACL allow/deny as often as you like. It is on a per
stream basis. The first match defines the action. If there are no matches,
then the default is the inverse of the last ACL statement.

Thus 'ACL allow localhost' only allows access from localhost.
'ACL deny 1.0.0.0 1.255.255.255' would deny the whole of network 1 and
allow everybody else.

@section Global options
@table @option
@item HTTPPort @var{port_number}
@item Port @var{port_number}
@item RTSPPort @var{port_number}

@var{HTTPPort} sets the HTTP server listening TCP port number,
@var{RTSPPort} sets the RTSP server listening TCP port number.

@var{Port} is the equivalent of @var{HTTPPort} and is deprecated.

You must select a different port from your standard HTTP web server if
it is running on the same computer.

If not specified, no corresponding server will be created.

@item HTTPBindAddress @var{ip_address}
@item BindAddress @var{ip_address}
@item RTSPBindAddress @var{ip_address}
Set address on which the HTTP/RTSP server is bound. Only useful if you
have several network interfaces.

@var{BindAddress} is the equivalent of @var{HTTPBindAddress} and is
deprecated.

@item MaxHTTPConnections @var{n}
Set number of simultaneous HTTP connections that can be handled. It
has to be defined @emph{before} the @option{MaxClients} parameter,
since it defines the @option{MaxClients} maximum limit.

Default value is 2000.

@item MaxClients @var{n}
Set number of simultaneous requests that can be handled. Since
@command{ffserver} is very fast, it is more likely that you will want
to leave this high and use @option{MaxBandwidth}.

Default value is 5.

@item MaxBandwidth @var{kbps}
Set the maximum amount of kbit/sec that you are prepared to consume
when streaming to clients.

Default value is 1000.

@item CustomLog @var{filename}
Set access log file (uses standard Apache log file format). '-' is the
standard output.

If not specified @command{ffserver} will produce no log.

In case the commandline option @option{-d} is specified this option is
ignored, and the log is written to standard output.

@item NoDaemon
Set no-daemon mode. This option is currently ignored since now
@command{ffserver} will always work in no-daemon mode, and is
deprecated.

@item UseDefaults
@item NoDefaults
Control whether default codec options are used for the all streams or not.
Each stream may overwrite this setting for its own. Default is @var{UseDefaults}.
The last occurrence overrides the previous if multiple definitions exist.
@end table

@section Feed section

A Feed section defines a feed provided to @command{ffserver}.

Each live feed contains one video and/or audio sequence coming from an
@command{ffmpeg} encoder or another @command{ffserver}. This sequence
may be encoded simultaneously with several codecs at several
resolutions.

A feed instance specification is introduced by a line in the form:
@example
<Feed FEED_FILENAME>
@end example

where @var{FEED_FILENAME} specifies the unique name of the FFM stream.

The following options are recognized within a Feed section.

@table @option
@item File @var{filename}
@item ReadOnlyFile @var{filename}
Set the path where the feed file is stored on disk.

If not specified, the @file{/tmp/FEED.ffm} is assumed, where
@var{FEED} is the feed name.

If @option{ReadOnlyFile} is used the file is marked as read-only and
it will not be deleted or updated.

@item Truncate
Truncate the feed file, rather than appending to it. By default
@command{ffserver} will append data to the file, until the maximum
file size value is reached (see @option{FileMaxSize} option).

@item FileMaxSize @var{size}
Set maximum size of the feed file in bytes. 0 means unlimited. The
postfixes @code{K} (2^10), @code{M} (2^20), and @code{G} (2^30) are
recognized.

Default value is 5M.

@item Launch @var{args}
Launch an @command{ffmpeg} command when creating @command{ffserver}.

@var{args} must be a sequence of arguments to be provided to an
@command{ffmpeg} instance. The first provided argument is ignored, and
it is replaced by a path with the same dirname of the @command{ffserver}
instance, followed by the remaining argument and terminated with a
path corresponding to the feed.

When the launched process exits, @command{ffserver} will launch
another program instance.

In case you need a more complex @command{ffmpeg} configuration,
e.g. if you need to generate multiple FFM feeds with a single
@command{ffmpeg} instance, you should launch @command{ffmpeg} by hand.

This option is ignored in case the commandline option @option{-n} is
specified.

@item ACL @var{spec}
Specify the list of IP address which are allowed or denied to write
the feed. Multiple ACL options can be specified.
@end table

@section Stream section

A Stream section defines a stream provided by @command{ffserver}, and
identified by a single name.

The stream is sent when answering a request containing the stream
name.

A stream section must be introduced by the line:
@example
<Stream STREAM_NAME>
@end example

where @var{STREAM_NAME} specifies the unique name of the stream.

The following options are recognized within a Stream section.

Encoding options are marked with the @emph{encoding} tag, and they are
used to set the encoding parameters, and are mapped to libavcodec
encoding options. Not all encoding options are supported, in
particular it is not possible to set encoder private options. In order
to override the encoding options specified by @command{ffserver}, you
can use the @command{ffmpeg} @option{override_ffserver} commandline
option.

Only one of the @option{Feed} and @option{File} options should be set.

@table @option
@item Feed @var{feed_name}
Set the input feed. @var{feed_name} must correspond to an existing
feed defined in a @code{Feed} section.

When this option is set, encoding options are used to setup the
encoding operated by the remote @command{ffmpeg} process.

@item File @var{filename}
Set the filename of the pre-recorded input file to stream.

When this option is set, encoding options are ignored and the input
file content is re-streamed as is.

@item Format @var{format_name}
Set the format of the output stream.

Must be the name of a format recognized by FFmpeg. If set to
@samp{status}, it is treated as a status stream.

@item InputFormat @var{format_name}
Set input format. If not specified, it is automatically guessed.

@item Preroll @var{n}
Set this to the number of seconds backwards in time to start. Note that
most players will buffer 5-10 seconds of video, and also you need to allow
for a keyframe to appear in the data stream.

Default value is 0.

@item StartSendOnKey
Do not send stream until it gets the first key frame. By default
@command{ffserver} will send data immediately.

@item MaxTime @var{n}
Set the number of seconds to run. This value set the maximum duration
of the stream a client will be able to receive.

A value of 0 means that no limit is set on the stream duration.

@item ACL @var{spec}
Set ACL for the stream.

@item DynamicACL @var{spec}

@item RTSPOption @var{option}

@item MulticastAddress @var{address}

@item MulticastPort @var{port}

@item MulticastTTL @var{integer}

@item NoLoop

@item FaviconURL @var{url}
Set favicon (favourite icon) for the server status page. It is ignored
for regular streams.

@item Author @var{value}
@item Comment @var{value}
@item Copyright @var{value}
@item Title @var{value}
Set metadata corresponding to the option. All these options are
deprecated in favor of @option{Metadata}.

@item Metadata @var{key} @var{value}
Set metadata value on the output stream.

@item UseDefaults
@item NoDefaults
Control whether default codec options are used for the stream or not.
Default is @var{UseDefaults} unless disabled globally.

@item NoAudio
@item NoVideo
Suppress audio/video.

@item AudioCodec @var{codec_name} (@emph{encoding,audio})
Set audio codec.

@item AudioBitRate @var{rate} (@emph{encoding,audio})
Set bitrate for the audio stream in kbits per second.

@item AudioChannels @var{n} (@emph{encoding,audio})
Set number of audio channels.

@item AudioSampleRate @var{n} (@emph{encoding,audio})
Set sampling frequency for audio. When using low bitrates, you should
lower this frequency to 22050 or 11025. The supported frequencies
depend on the selected audio codec.

@item AVOptionAudio [@var{codec}:]@var{option} @var{value} (@emph{encoding,audio})
Set generic or private option for audio stream.
Private option must be prefixed with codec name or codec must be defined before.

@item AVPresetAudio @var{preset} (@emph{encoding,audio})
Set preset for audio stream.

@item VideoCodec @var{codec_name} (@emph{encoding,video})
Set video codec.

@item VideoBitRate @var{n} (@emph{encoding,video})
Set bitrate for the video stream in kbits per second.

@item VideoBitRateRange @var{range} (@emph{encoding,video})
Set video bitrate range.

A range must be specified in the form @var{minrate}-@var{maxrate}, and
specifies the @option{minrate} and @option{maxrate} encoding options
expressed in kbits per second.

@item VideoBitRateRangeTolerance @var{n} (@emph{encoding,video})
Set video bitrate tolerance in kbits per second.

@item PixelFormat @var{pixel_format} (@emph{encoding,video})
Set video pixel format.

@item Debug @var{integer} (@emph{encoding,video})
Set video @option{debug} encoding option.

@item Strict @var{integer} (@emph{encoding,video})
Set video @option{strict} encoding option.

@item VideoBufferSize @var{n} (@emph{encoding,video})
Set ratecontrol buffer size, expressed in KB.

@item VideoFrameRate @var{n} (@emph{encoding,video})
Set number of video frames per second.

@item VideoSize (@emph{encoding,video})
Set size of the video frame, must be an abbreviation or in the form
@var{W}x@var{H}.  See @ref{video size syntax,,the Video size section
in the ffmpeg-utils(1) manual,ffmpeg-utils}.

Default value is @code{160x128}.

@item VideoIntraOnly (@emph{encoding,video})
Transmit only intra frames (useful for low bitrates, but kills frame rate).

@item VideoGopSize @var{n} (@emph{encoding,video})
If non-intra only, an intra frame is transmitted every VideoGopSize
frames. Video synchronization can only begin at an intra frame.

@item VideoTag @var{tag} (@emph{encoding,video})
Set video tag.

@item VideoHighQuality (@emph{encoding,video})
@item Video4MotionVector (@emph{encoding,video})

@item BitExact (@emph{encoding,video})
Set bitexact encoding flag.

@item IdctSimple (@emph{encoding,video})
Set simple IDCT algorithm.

@item Qscale @var{n} (@emph{encoding,video})
Enable constant quality encoding, and set video qscale (quantization
scale) value, expressed in @var{n} QP units.

@item VideoQMin @var{n} (@emph{encoding,video})
@item VideoQMax @var{n} (@emph{encoding,video})
Set video qmin/qmax.

@item VideoQDiff @var{integer} (@emph{encoding,video})
Set video @option{qdiff} encoding option.

@item LumiMask @var{float} (@emph{encoding,video})
@item DarkMask @var{float} (@emph{encoding,video})
Set @option{lumi_mask}/@option{dark_mask} encoding options.

@item AVOptionVideo [@var{codec}:]@var{option} @var{value} (@emph{encoding,video})
Set generic or private option for video stream.
Private option must be prefixed with codec name or codec must be defined before.

@item AVPresetVideo @var{preset} (@emph{encoding,video})
Set preset for video stream.

@var{preset} must be the path of a preset file.
@end table

@subsection Server status stream

A server status stream is a special stream which is used to show
statistics about the @command{ffserver} operations.

It must be specified setting the option @option{Format} to
@samp{status}.

@section Redirect section

A redirect section specifies where to redirect the requested URL to
another page.

A redirect section must be introduced by the line:
@example
<Redirect NAME>
@end example

where @var{NAME} is the name of the page which should be redirected.

It only accepts the option @option{URL}, which specify the redirection
URL.

@chapter Stream examples

@itemize
@item
Multipart JPEG
@example
<Stream test.mjpg>
Feed feed1.ffm
Format mpjpeg
VideoFrameRate 2
VideoIntraOnly
NoAudio
Strict -1
</Stream>
@end example

@item
Single JPEG
@example
<Stream test.jpg>
Feed feed1.ffm
Format jpeg
VideoFrameRate 2
VideoIntraOnly
VideoSize 352x240
NoAudio
Strict -1
</Stream>
@end example

@item
Flash
@example
<Stream test.swf>
Feed feed1.ffm
Format swf
VideoFrameRate 2
VideoIntraOnly
NoAudio
</Stream>
@end example

@item
ASF compatible
@example
<Stream test.asf>
Feed feed1.ffm
Format asf
VideoFrameRate 15
VideoSize 352x240
VideoBitRate 256
VideoBufferSize 40
VideoGopSize 30
AudioBitRate 64
StartSendOnKey
</Stream>
@end example

@item
MP3 audio
@example
<Stream test.mp3>
Feed feed1.ffm
Format mp2
AudioCodec mp3
AudioBitRate 64
AudioChannels 1
AudioSampleRate 44100
NoVideo
</Stream>
@end example

@item
Ogg Vorbis audio
@example
<Stream test.ogg>
Feed feed1.ffm
Metadata title "Stream title"
AudioBitRate 64
AudioChannels 2
AudioSampleRate 44100
NoVideo
</Stream>
@end example

@item
Real with audio only at 32 kbits
@example
<Stream test.ra>
Feed feed1.ffm
Format rm
AudioBitRate 32
NoVideo
</Stream>
@end example

@item
Real with audio and video at 64 kbits
@example
<Stream test.rm>
Feed feed1.ffm
Format rm
AudioBitRate 32
VideoBitRate 128
VideoFrameRate 25
VideoGopSize 25
</Stream>
@end example

@item
For stream coming from a file: you only need to set the input filename
and optionally a new format.

@example
<Stream file.rm>
File "/usr/local/httpd/htdocs/tlive.rm"
NoAudio
</Stream>
@end example

@example
<Stream file.asf>
File "/usr/local/httpd/htdocs/test.asf"
NoAudio
Metadata author "Me"
Metadata copyright "Super MegaCorp"
Metadata title "Test stream from disk"
Metadata comment "Test comment"
</Stream>
@end example
@end itemize

@c man end

@include config.texi
@ifset config-all
@ifset config-avutil
@include utils.texi
@end ifset
@ifset config-avcodec
@include codecs.texi
@include bitstream_filters.texi
@end ifset
@ifset config-avformat
@include formats.texi
@include protocols.texi
@end ifset
@ifset config-avdevice
@include devices.texi
@end ifset
@ifset config-swresample
@include resampler.texi
@end ifset
@ifset config-swscale
@include scaler.texi
@end ifset
@ifset config-avfilter
@include filters.texi
@end ifset
@end ifset

@chapter See Also

@ifhtml
@ifset config-all
@url{ffserver.html,ffserver},
@end ifset
@ifset config-not-all
@url{ffserver-all.html,ffserver-all},
@end ifset
the @file{doc/ffserver.conf} example,
@url{ffmpeg.html,ffmpeg}, @url{ffplay.html,ffplay}, @url{ffprobe.html,ffprobe},
@url{ffmpeg-utils.html,ffmpeg-utils},
@url{ffmpeg-scaler.html,ffmpeg-scaler},
@url{ffmpeg-resampler.html,ffmpeg-resampler},
@url{ffmpeg-codecs.html,ffmpeg-codecs},
@url{ffmpeg-bitstream-filters.html,ffmpeg-bitstream-filters},
@url{ffmpeg-formats.html,ffmpeg-formats},
@url{ffmpeg-devices.html,ffmpeg-devices},
@url{ffmpeg-protocols.html,ffmpeg-protocols},
@url{ffmpeg-filters.html,ffmpeg-filters}
@end ifhtml

@ifnothtml
@ifset config-all
ffserver(1),
@end ifset
@ifset config-not-all
ffserver-all(1),
@end ifset
the @file{doc/ffserver.conf} example, ffmpeg(1), ffplay(1), ffprobe(1),
ffmpeg-utils(1), ffmpeg-scaler(1), ffmpeg-resampler(1),
ffmpeg-codecs(1), ffmpeg-bitstream-filters(1), ffmpeg-formats(1),
ffmpeg-devices(1), ffmpeg-protocols(1), ffmpeg-filters(1)
@end ifnothtml

@include authors.texi

@ignore

@setfilename ffserver
@settitle ffserver video server

@end ignore

@bye
