\input texinfo @c -*- texinfo -*-

@settitle Developer Documentation
@titlepage
@center @titlefont{Developer Documentation}
@end titlepage

@top

@contents

@chapter Developers Guide

@section API
@itemize @bullet
@item libavcodec is the library containing the codecs (both encoding and
decoding). Look at @file{libavcodec/apiexample.c} to see how to use it.

@item libavformat is the library containing the file format handling (mux and
demux code for several formats). Look at @file{ffplay.c} to use it in a
player. See @file{libavformat/output-example.c} to use it to generate
audio or video streams.

@end itemize

@section Integrating libavcodec or libavformat in your program

You can integrate all the source code of the libraries to link them
statically to avoid any version problem. All you need is to provide a
'config.mak' and a 'config.h' in the parent directory. See the defines
generated by ./configure to understand what is needed.

You can use libavcodec or libavformat in your commercial program, but
@emph{any patch you make must be published}. The best way to proceed is
to send your patches to the FFmpeg mailing list.

@section Contributing

There are 3 ways by which code gets into ffmpeg.
@itemize @bullet
@item Submitting Patches to the main developer mailing list
      see @ref{Submitting patches} for details.
@item Directly committing changes to the main tree.
@item Committing changes to a git clone, for example on github.com or
      gitorious.org. And asking us to merge these changes.
@end itemize

Whichever way, changes should be reviewed by the maintainer of the code
before they are committed. And they should follow the @ref{Coding Rules}.
The developer making the commit and the author are responsible for their changes
and should try to fix issues their commit causes.

@anchor{Coding Rules}
@section Coding Rules

@subsection Code formatting conventions

There are the following guidelines regarding the indentation in files:
@itemize @bullet
@item
Indent size is 4.
@item
The TAB character is forbidden outside of Makefiles as is any
form of trailing whitespace. Commits containing either will be
rejected by the git repository.
@item
You should try to limit your code lines to 80 characters; however, do so if
and only if this improves readability.
@end itemize
The presentation is one inspired by 'indent -i4 -kr -nut'.

The main priority in FFmpeg is simplicity and small code size in order to
minimize the bug count.

@subsection Comments
Use the JavaDoc/Doxygen  format (see examples below) so that code documentation
can be generated automatically. All nontrivial functions should have a comment
above them explaining what the function does, even if it is just one sentence.
All structures and their member variables should be documented, too.

Avoid Qt-style and similar Doxygen syntax with @code{!} in it, i.e. replace
@code{//!} with @code{///} and similar.  Also @@ syntax should be employed
for markup commands, i.e. use @code{@@param} and not @code{\param}.

@example
/**
 * @@file
 * MPEG codec.
 * @@author ...
 */

/**
 * Summary sentence.
 * more text ...
 * ...
 */
typedef struct Foobar@{
    int var1; /**< var1 description */
    int var2; ///< var2 description
    /** var3 description */
    int var3;
@} Foobar;

/**
 * Summary sentence.
 * more text ...
 * ...
 * @@param my_parameter description of my_parameter
 * @@return return value description
 */
int myfunc(int my_parameter)
...
@end example

@subsection C language features

FFmpeg is programmed in the ISO C90 language with a few additional
features from ISO C99, namely:
@itemize @bullet
@item
the @samp{inline} keyword;
@item
@samp{//} comments;
@item
designated struct initializers (@samp{struct s x = @{ .i = 17 @};})
@item
compound literals (@samp{x = (struct s) @{ 17, 23 @};})
@end itemize

These features are supported by all compilers we care about, so we will not
accept patches to remove their use unless they absolutely do not impair
clarity and performance.

All code must compile with recent versions of GCC and a number of other
currently supported compilers. To ensure compatibility, please do not use
additional C99 features or GCC extensions. Especially watch out for:
@itemize @bullet
@item
mixing statements and declarations;
@item
@samp{long long} (use @samp{int64_t} instead);
@item
@samp{__attribute__} not protected by @samp{#ifdef __GNUC__} or similar;
@item
GCC statement expressions (@samp{(x = (@{ int y = 4; y; @})}).
@end itemize

@subsection Naming conventions
All names are using underscores (_), not CamelCase. For example, @samp{avfilter_get_video_buffer} is
a valid function name and @samp{AVFilterGetVideo} is not. The exception from this are type names, like
for example structs and enums; they should always be in the CamelCase


There are following conventions for naming variables and functions:
@itemize @bullet
@item
For local variables no prefix is required.
@item
For variables and functions declared as @code{static} no prefixes are required.
@item
For variables and functions used internally by the library, @code{ff_} prefix
should be used.
For example, @samp{ff_w64_demuxer}.
@item
For variables and functions used internally across multiple libraries, use
@code{avpriv_}. For example, @samp{avpriv_aac_parse_header}.
@item
For exported names, each library has its own prefixes. Just check the existing
code and name accordingly.
@end itemize

@subsection Miscellanous conventions
@itemize @bullet
@item
fprintf and printf are forbidden in libavformat and libavcodec,
please use av_log() instead.
@item
Casts should be used only when necessary. Unneeded parentheses
should also be avoided if they don't make the code easier to understand.
@end itemize

@subsection Editor configuration
In order to configure Vim to follow FFmpeg formatting conventions, paste
the following snippet into your @file{.vimrc}:
@example
" indentation rules for FFmpeg: 4 spaces, no tabs
set expandtab
set shiftwidth=4
set softtabstop=4
" allow tabs in Makefiles
autocmd FileType make set noexpandtab shiftwidth=8 softtabstop=8
" Trailing whitespace and tabs are forbidden, so highlight them.
highlight ForbiddenWhitespace ctermbg=red guibg=red
match ForbiddenWhitespace /\s\+$\|\t/
" Do not highlight spaces at the end of line while typing on that line.
autocmd InsertEnter * match ForbiddenWhitespace /\t\|\s\+\%#\@@<!$/
@end example

For Emacs, add these roughly equivalent lines to your @file{.emacs.d/init.el}:
@example
(setq c-default-style "k&r")
(setq-default c-basic-offset 4)
(setq-default indent-tabs-mode nil)
(setq-default show-trailing-whitespace t)
@end example

@section Development Policy

@enumerate
@item
   Contributions should be licensed under the LGPL 2.1, including an
   "or any later version" clause, or the MIT license.  GPL 2 including
   an "or any later version" clause is also acceptable, but LGPL is
   preferred.
@item
   You must not commit code which breaks FFmpeg! (Meaning unfinished but
   enabled code which breaks compilation or compiles but does not work or
   breaks the regression tests)
   You can commit unfinished stuff (for testing etc), but it must be disabled
   (#ifdef etc) by default so it does not interfere with other developers'
   work.
@item
   You do not have to over-test things. If it works for you, and you think it
   should work for others, then commit. If your code has problems
   (portability, triggers compiler bugs, unusual environment etc) they will be
   reported and eventually fixed.
@item
   Do not commit unrelated changes together, split them into self-contained
   pieces. Also do not forget that if part B depends on part A, but A does not
   depend on B, then A can and should be committed first and separate from B.
   Keeping changes well split into self-contained parts makes reviewing and
   understanding them on the commit log mailing list easier. This also helps
   in case of debugging later on.
   Also if you have doubts about splitting or not splitting, do not hesitate to
   ask/discuss it on the developer mailing list.
@item
   Do not change behavior of the programs (renaming options etc) or public
   API or ABI without first discussing it on the ffmpeg-devel mailing list.
   Do not remove functionality from the code. Just improve!

   Note: Redundant code can be removed.
@item
   Do not commit changes to the build system (Makefiles, configure script)
   which change behavior, defaults etc, without asking first. The same
   applies to compiler warning fixes, trivial looking fixes and to code
   maintained by other developers. We usually have a reason for doing things
   the way we do. Send your changes as patches to the ffmpeg-devel mailing
   list, and if the code maintainers say OK, you may commit. This does not
   apply to files you wrote and/or maintain.
@item
   We refuse source indentation and other cosmetic changes if they are mixed
   with functional changes, such commits will be rejected and removed. Every
   developer has his own indentation style, you should not change it. Of course
   if you (re)write something, you can use your own style, even though we would
   prefer if the indentation throughout FFmpeg was consistent (Many projects
   force a given indentation style - we do not.). If you really need to make
   indentation changes (try to avoid this), separate them strictly from real
   changes.

   NOTE: If you had to put if()@{ .. @} over a large (> 5 lines) chunk of code,
   then either do NOT change the indentation of the inner part within (do not
   move it to the right)! or do so in a separate commit
@item
   Always fill out the commit log message. Describe in a few lines what you
   changed and why. You can refer to mailing list postings if you fix a
   particular bug. Comments such as "fixed!" or "Changed it." are unacceptable.
   Recommended format:
   area changed: Short 1 line description

   details describing what and why and giving references.
@item
   Make sure the author of the commit is set correctly. (see git commit --author)
   If you apply a patch, send an
   answer to ffmpeg-devel (or wherever you got the patch from) saying that
   you applied the patch.
@item
   When applying patches that have been discussed (at length) on the mailing
   list, reference the thread in the log message.
@item
    Do NOT commit to code actively maintained by others without permission.
    Send a patch to ffmpeg-devel instead. If no one answers within a reasonable
    timeframe (12h for build failures and security fixes, 3 days small changes,
    1 week for big patches) then commit your patch if you think it is OK.
    Also note, the maintainer can simply ask for more time to review!
@item
    Subscribe to the ffmpeg-cvslog mailing list. The diffs of all commits
    are sent there and reviewed by all the other developers. Bugs and possible
    improvements or general questions regarding commits are discussed there. We
    expect you to react if problems with your code are uncovered.
@item
    Update the documentation if you change behavior or add features. If you are
    unsure how best to do this, send a patch to ffmpeg-devel, the documentation
    maintainer(s) will review and commit your stuff.
@item
    Try to keep important discussions and requests (also) on the public
    developer mailing list, so that all developers can benefit from them.
@item
    Never write to unallocated memory, never write over the end of arrays,
    always check values read from some untrusted source before using them
    as array index or other risky things.
@item
    Remember to check if you need to bump versions for the specific libav*
    parts (libavutil, libavcodec, libavformat) you are changing. You need
    to change the version integer.
    Incrementing the first component means no backward compatibility to
    previous versions (e.g. removal of a function from the public API).
    Incrementing the second component means backward compatible change
    (e.g. addition of a function to the public API or extension of an
    existing data structure).
    Incrementing the third component means a noteworthy binary compatible
    change (e.g. encoder bug fix that matters for the decoder).
@item
    Compiler warnings indicate potential bugs or code with bad style. If a type of
    warning always points to correct and clean code, that warning should
    be disabled, not the code changed.
    Thus the remaining warnings can either be bugs or correct code.
    If it is a bug, the bug has to be fixed. If it is not, the code should
    be changed to not generate a warning unless that causes a slowdown
    or obfuscates the code.
@item
    If you add a new file, give it a proper license header. Do not copy and
    paste it from a random place, use an existing file as template.
@end enumerate

We think our rules are not too hard. If you have comments, contact us.

Note, these rules are mostly borrowed from the MPlayer project.

@anchor{Submitting patches}
@section Submitting patches

First, read the @ref{Coding Rules} above if you did not yet, in particular
the rules regarding patch submission.

When you submit your patch, please use @code{git format-patch} or
@code{git send-email}. We cannot read other diffs :-)

Also please do not submit a patch which contains several unrelated changes.
Split it into separate, self-contained pieces. This does not mean splitting
file by file. Instead, make the patch as small as possible while still
keeping it as a logical unit that contains an individual change, even
if it spans multiple files. This makes reviewing your patches much easier
for us and greatly increases your chances of getting your patch applied.

Use the patcheck tool of FFmpeg to check your patch.
The tool is located in the tools directory.

Run the @ref{Regression tests} before submitting a patch in order to verify
it does not cause unexpected problems.

Patches should be posted as base64 encoded attachments (or any other
encoding which ensures that the patch will not be trashed during
transmission) to the ffmpeg-devel mailing list, see
@url{http://lists.ffmpeg.org/mailman/listinfo/ffmpeg-devel}

It also helps quite a bit if you tell us what the patch does (for example
'replaces lrint by lrintf'), and why (for example '*BSD isn't C99 compliant
and has no lrint()')

Also please if you send several patches, send each patch as a separate mail,
do not attach several unrelated patches to the same mail.

Your patch will be reviewed on the mailing list. You will likely be asked
to make some changes and are expected to send in an improved version that
incorporates the requests from the review. This process may go through
several iterations. Once your patch is deemed good enough, some developer
will pick it up and commit it to the official FFmpeg tree.

Give us a few days to react. But if some time passes without reaction,
send a reminder by email. Your patch should eventually be dealt with.


@section New codecs or formats checklist

@enumerate
@item
    Did you use av_cold for codec initialization and close functions?
@item
    Did you add a long_name under NULL_IF_CONFIG_SMALL to the AVCodec or
    AVInputFormat/AVOutputFormat struct?
@item
    Did you bump the minor version number (and reset the micro version
    number) in @file{libavcodec/version.h} or @file{libavformat/version.h}?
@item
    Did you register it in @file{allcodecs.c} or @file{allformats.c}?
@item
    Did you add the CodecID to @file{avcodec.h}?
@item
    If it has a fourCC, did you add it to @file{libavformat/riff.c},
    even if it is only a decoder?
@item
    Did you add a rule to compile the appropriate files in the Makefile?
    Remember to do this even if you're just adding a format to a file that is
    already being compiled by some other rule, like a raw demuxer.
@item
    Did you add an entry to the table of supported formats or codecs in
    @file{doc/general.texi}?
@item
    Did you add an entry in the Changelog?
@item
    If it depends on a parser or a library, did you add that dependency in
    configure?
@item
    Did you @code{git add} the appropriate files before committing?
@item
    Did you make sure it compiles standalone, i.e. with
    @code{configure --disable-everything --enable-decoder=foo}
    (or @code{--enable-demuxer} or whatever your component is)?
@end enumerate


@section patch submission checklist

@enumerate
@item
    Does @code{make fate} pass with the patch applied?
@item
    Was the patch generated with git format-patch or send-email?
@item
    Did you sign off your patch? (git commit -s)
    See @url{http://kerneltrap.org/files/Jeremy/DCO.txt} for the meaning
    of sign off.
@item
    Did you provide a clear git commit log message?
@item
    Is the patch against latest FFmpeg git master branch?
@item
    Are you subscribed to ffmpeg-devel?
    (the list is subscribers only due to spam)
@item
    Have you checked that the changes are minimal, so that the same cannot be
    achieved with a smaller patch and/or simpler final code?
@item
    If the change is to speed critical code, did you benchmark it?
@item
    If you did any benchmarks, did you provide them in the mail?
@item
    Have you checked that the patch does not introduce buffer overflows or
    other security issues?
@item
    Did you test your decoder or demuxer against damaged data? If no, see
    tools/trasher and the noise bitstream filter. Your decoder or demuxer
    should not crash or end in a (near) infinite loop when fed damaged data.
@item
    Does the patch not mix functional and cosmetic changes?
@item
    Did you add tabs or trailing whitespace to the code? Both are forbidden.
@item
    Is the patch attached to the email you send?
@item
    Is the mime type of the patch correct? It should be text/x-diff or
    text/x-patch or at least text/plain and not application/octet-stream.
@item
    If the patch fixes a bug, did you provide a verbose analysis of the bug?
@item
    If the patch fixes a bug, did you provide enough information, including
    a sample, so the bug can be reproduced and the fix can be verified?
    Note please do not attach samples >100k to mails but rather provide a
    URL, you can upload to ftp://upload.ffmpeg.org
@item
    Did you provide a verbose summary about what the patch does change?
@item
    Did you provide a verbose explanation why it changes things like it does?
@item
    Did you provide a verbose summary of the user visible advantages and
    disadvantages if the patch is applied?
@item
    Did you provide an example so we can verify the new feature added by the
    patch easily?
@item
    If you added a new file, did you insert a license header? It should be
    taken from FFmpeg, not randomly copied and pasted from somewhere else.
@item
    You should maintain alphabetical order in alphabetically ordered lists as
    long as doing so does not break API/ABI compatibility.
@item
    Lines with similar content should be aligned vertically when doing so
    improves readability.
@item
    Consider to add a regression test for your code.
@item
    If you added YASM code please check that things still work with --disable-yasm
@end enumerate

@section Patch review process

All patches posted to ffmpeg-devel will be reviewed, unless they contain a
clear note that the patch is not for the git master branch.
Reviews and comments will be posted as replies to the patch on the
mailing list. The patch submitter then has to take care of every comment,
that can be by resubmitting a changed patch or by discussion. Resubmitted
patches will themselves be reviewed like any other patch. If at some point
a patch passes review with no comments then it is approved, that can for
simple and small patches happen immediately while large patches will generally
have to be changed and reviewed many times before they are approved.
After a patch is approved it will be committed to the repository.

We will review all submitted patches, but sometimes we are quite busy so
especially for large patches this can take several weeks.

If you feel that the review process is too slow and you are willing to try to
take over maintainership of the area of code you change then just clone
git master and maintain the area of code there. We will merge each area from
where its best maintained.

When resubmitting patches, please do not make any significant changes
not related to the comments received during review. Such patches will
be rejected. Instead, submit significant changes or new features as
separate patches.

@anchor{Regression tests}
@section Regression tests

Before submitting a patch (or committing to the repository), you should at least
test that you did not break anything.

Running 'make fate' accomplishes this, please see @url{fate.html} for details.

[Of course, some patches may change the results of the regression tests. In
this case, the reference results of the regression tests shall be modified
accordingly].

@bye
